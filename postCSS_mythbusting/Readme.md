# 4 мифа о PostCSS

_Вы читаете перевод статьи [PostCSS Mythbusting: Four PostCSS Myths Busted](http://www.sitepoint.com/postcss-mythbusting/)._

Когда появляется новый инструмент для работы с фронтендом, всегда возникает вопрос о его потенциале на уже сформировавшемся рынке. Предлагает ли он разработчикам нечто новое? Стоит ли тратить время и усилия на его освоение и внедрение?

С самого начала [PostCSS](http://postcss.org/) поставил перед собой интересную задачу. На фоне его соперничества с такими обработчиками CSS, как Sass и Less, появились некоторые заблуждения, связанные с тем, как его воспринимают и используют.

Давайте развеем некоторые из самых частых мифов о PostCSS и посмотрим, как с его помощью можно усовершенствовать ваш рабочий процесс.

_Важно: если вы хотите больше узнать о том, что такое PostCSS и как его настроить, прочитайте статью [introduction to PostCSS](http://www.sitepoint.com/an-introduction-to-postcss/) и возвращайтесь развеивать мифы!_

## Миф 1: PostCSS — это пре- или пост- процессор

Давайте начнем с, пожалуй, самого большого заблуждения, связанного с PostCSS.

Когда PostCSS только вышел, его позиционировали как «постпроцессор». Большинство первых PostCSS плагинов брали валидный CSS и как-то его улучшали. Этот подход отличался от того, что использовали препроцессоры, бравшие свой специальный синтаксис и компилировавшие его в валидный CSS.

Однако, называть PostCSS постпроцессором в некотором роде неверно, поскольку это преуменьшает его возможности. Я предпочитаю называть его просто CSS процессором, так как он может выполнять самые разные задачи, используя PostCSS плагины, и действовать на разных этапах работы с CSS.

Некоторые PostCSS плагины берут специальный синтаксис и переводят его в валидный CSS, как будто вы работаете со стандартным препроцессором вроде Sass. В качестве примера можно привести [PostCSS Nested](https://github.com/postcss/postcss-nested), который позволяет писать вложенные селекторы, как это сделано в Sass и Less. Другие PostCSS плагины берут валидный CSS и расширяют его, как, например, делает наиболее известный PostCSS плагин — [Autoprefixer](https://github.com/postcss/autoprefixer). Он автоматически добавляет вендорные префиксы в ваши стили.

Есть PostCSS плагины, которые вообще никак не трансформируют ваш CSS. Вместо этого они анализируют ваш код и подсказывают, как его улучшить. Например, [Stylelint](http://stylelint.io/) используется в качестве линтера CSS, а [Colorguard](https://github.com/SlexAxton/css-colorguard) помогает выработать единую цветовую палитру в проекте.

В дополнение к этому, PostCSS парсит как стандартный CSS, так и SCSS синтаксис. Это значит, что вы можете обрабатывать PostCSS плагинами свои `.scss` файлы. Как это делается — поговорим в следующем разделе.

Так что можно развеять первый миф — PostCSS это ни пре-, ни пост- процессор. Это CSS процессор, который может обработать или проанализировать стили на различных этапах вашего рабочего процесса.

## Миф 2: PostCSS — альтернатива препроцессорам вроде Sass или Less

Частое заблуждение среди разработчиков – попытка сравнить PostCSS с существующими препроцессорами, вроде Sass или Less.

Я думаю, так произошло из-за того, что первые PostCSS плагины были нацелены на поддержку тех возможностей, которые мы привыкли видеть в препроцессорах: переменных, условных операторов, циклов и миксинов. С ростом PostCSS сообщества возник обширный набор плагинов, представляющих новые возможности, отличающие PostCSS от препроцессоров.

Поэтому, хотя вы и можете использовать PostCSS как альтернативу препроцессорам, вы также можете расширить текущий набор инструментов, добавив новые возможности в свой любимый препроцессор.

PostCSS подходит для парсинга как CSS, так и [SCSS синтаксиса](https://github.com/postcss/postcss-scss), а это значит, что вы можете использовать PostCSS как до, так и после компиляции Sass. Например, на текущем проекте я использую PostCSS чтобы прогнать свои Sass файлы через Stylelint перед тем, как компилировать их в CSS. А после этого получившийся CSS расширяется плагинами вроде Autoprefixer и [postcss-assets](https://github.com/assetsjs/postcss-assets), которые добавляют вендорные префиксы и встраивают графику через data URIs. Так что ваш рабочий процесс может выглядеть примерно так:

![using postcss](https://raw.githubusercontent.com/aalexeev239/articles/postCSS-mythbusting/postCSS_mythbusting/img/scheme.png)

В общем, то, как вы будете использовать PostCSS, зависит от вас. Хотите использовать его отдельным CSS обработчиком — пожалуйста. А если вас полностью устраивает Sass или Less, помните, что PostCSS также может работать бок о бок с этими инструментами, добавляя возможности, которые препроцессор делать не умеет.

## Миф 3: PostCSS сделает настройку сложной

Я знаю, о чём вы сейчас думаете. Мир фронтенд инструментов и так слишком обширен — зачем добавлять ещё один инструмент и делать процесс сборки более запутанным? Вопрос закономерный, но ответить на него вам нужно будет самостоятельно, в зависимости от тех проектов, над которыми вы работаете.

Вы можете уже использовать PostCSS, сами того не осознавая. Если вы используете  Autoprefixer для добавления вендорных префиксов в CSS, то вы уже используете PostCSS. Autoprefixer — это PostCSS плагин, который можно добавить в обычные таск-раннеры вроде Grunt и Gulp через плагины [grunt-postcss](https://github.com/postcss/autoprefixer#grunt) или [gulp-postcss](https://github.com/postcss/autoprefixer#gulp). Есть способы это сделать и для других инструментов, таких как Webpack — подробности вы найдете в [документации PostCSS](https://github.com/postcss/postcss#usage). 

Если вы раньше не использовали эти плагины для Autoprefixer-а, самое время начать. Вы увидите, как просто можно подключить другие PostCSS плагины. Например, если бы я использовал Autoprefixer с Gulp, мой код выглядел бы так:

```
return gulp.src( ['/**/*.css'] )
  // задачи PostCSS для обработки CSS файлов
  .pipe( postcss([
    autoprefixer({
      browsers: [
        '> 5%',
        'last 2 versions',
        'ie > 7'
      ] 
    }) // автоматические префиксы для различных браузеров
    … // сюда добавляются любые другие PostCSS плагины
]) )
.pipe( gulp.dest( CSS_DEST_PATH ) );
```

Как видите, дополнительные плагины можно просто добавить к Autoprefixer-у в любой момент, когда вы заходите встроить их в свою работу.

Если по каким-либо причинам вы не используете Autoprefixer, посмотрите на другие [доступные плагины](http://postcss.parts/). Каждый проект и каждая команда разработчиков отличаются друг от друга, и даже если вы просто пролистаете список доступных плагинов, вы сможете найди там что-то полезное для вас и для вашей команды.

Добавить PostCSS в свой рабочий процесс не сложнее, чем подключить какой-нибудь Grunt или Gulp плагин. Не пренебрегайте этим лишь потому, что добавляется ещё один шаг сборки: если этот шаг поможет вам улучшить работу с CSS, он стоит того.

## Миф 4: PostCSS не предлагает мне ничего, чего не может мой препроцессор

Суть мифа в том, что PostCSS напрямую сравнивают с Sass и Less. А именно, рассматривают плагины, эмулирующие функциональность Sass.

PostCSS сильно вырос за последние 12 месяцев (1 год, *прим. переводчика*). Хотя старые плагины по-прежнему доступны, появилось большое количество новых, и круг возможностей, которые они предлагают, заметно расширился.

Если вас все устраивает в текущем препроцессоре и раньше вы не использовали PostCSS, поскольку он предлагал всё то же самое, стоит взглянуть на него ещё раз. К тому же, такие плагины, как [Stylelint](http://stylelint.io/), [PostCSS Stats](https://github.com/cssstats/postcss-cssstats) и [doiuse](https://github.com/anandthakker/doiuse) могут обеспечить автоматический анализ вашего CSS, чего не предложит стандартный препроцессор.

Также можно оптимировать код, например, минифицировать [SVG](https://github.com/ben-eb/postcss-svgo) и [CSS](https://github.com/ben-eb/cssnano), предоставить более изящные способы добавления фоллбэков для стилей, чем миксины.

Если вы хотите поэкспериментировать с [CSS модулями](http://www.sitepoint.com/understanding-css-modules-methodology/), то и тут у PostCSS [найдется подходящий плагин](https://github.com/postcss/postcss#solve-global-css-problem).

Главная вещь, о которой стоит помнить при работе с PostCSS – то, что это до сих пор относительно новый инструмент. Пока сообщество растёт, будет создаваться больше плагинов, решающих интересные проблемы CSS. Загляните в каталог доступных плагинов на [postcss.parts](http://postcss.parts/).

В общем, PostCSS предлагает множество уникальных возможностей, не доступных другим препроцессорам. Стоит уделить время тому, чтобы ознакомиться с ними. Возможно, вы найдете то, что позволит вам с легкостью расширить возможности вашего текущего препроцессора.

## Итого

PostCSS — это мощный инструмент процессинга CSS, который может улучшить рабочий процесс любого фронтенд разработчика.  Он быстро встраивается в работу и предлагает удобные способы работы с CSS, препроцессорами и написанием кода.

Если вы раньше рассматривали на PostCSS и пренебрегли им по каким-либо причинам, я рекомендую вам пересмотреть свои взгляды. Это инструмент, способный улучшить любой процесс фронтенд разработки.

_Автор: Ashley Nolan_

_Оригинал статьи: [http://www.sitepoint.com/postcss-mythbusting/](http://www.sitepoint.com/postcss-mythbusting/)_

_Перевел [Андрей Алексеев](https://github.com/aalexeev239)_





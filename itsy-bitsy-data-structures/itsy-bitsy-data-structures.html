James Kyle как-то раз взял и написал пост про структуры данных, добавив их реализацию на JavaScript. А я взял и перевёл.
<br><br>
<b>Дисклеймер:</b> в посте много ascii-графики. Не стоит его читать с мобильного устройства — вас разочарует форматирование текста.
<br><br>
<img src="https://habrastorage.org/files/8b6/72f/6ff/8b672f6ff3f4458b925530a9462a7694.png"/>
<cut>
<br><br>
Сегодня мы узнаем всё о структурах данных.
<br><br>
«Оооооой как интересно...», да?
<br><br>
Да уж, не самая сочная тема на сей день, однако крайне важная. Не для того, чтобы сдавать курсы наподобие CS101, а чтобы лучше разбираться в программировании.
<br><br>
Знание структур данных поможет вам:
<ul>
    <li>Управлять сложностью своих программ, делая их доступней для понимания.</li>
    <li>Создавать высокопроизводительные программы, эффективно работающие с памятью.</li>
</ul>
Я считаю, что первое важнее. Правильная структура данных может кардинально упростить код, устраняя запутанную логику.
<br><br>
Второй пункт тоже важен. Когда учитываются производительность или память программы, правильный выбор структуры данных значительно сказывается на работе.
<br><br>
Чтобы познакомиться со структурами данных, мы реализуем некоторые из них. Не беспокойтесь, код будет лаконичен. На самом деле, тут больше комментариев, а кода между ними — раз, два и обчёлся.
<br><br>
<code>
<pre>
============================================================================
,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
============================================================================
</pre>
</code>
<h3>Что такое структуры данных?</h3>
По сути, это способы хранить и организовывать данные, чтобы эффективней решать различные задачи. Данные можно представить по-разному. В зависимости от того, что это за данные и что вы собираетесь с ними делать, одно представление подойдёт лучше других.
<br><br>
Чтобы понять, почему так происходит, сперва поговорим об алгоритмах.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                                                                           *
 *                        ,--,--.    ,--,--.                                 *
 *   ,----------.        |   |   |  |   |   |            _____               *
 *  |`----------'|       |   |   |  |   |   |           |     |    ,------.  *
 *  |            |       |   |   |  |   |   |      ,--. | o o |   |`------'| *
 *  |            |      ,| +-|-+ |  | +-|-+ |`     |  | |_____|   |        | *
 *  |            | ,:==| | |###|======|###| | |====#==#====#=,,   |        | *
 *  |            | ||   `| +---+ |  | +---+ |'  ,,=#==#====O=``  ,|        | *
 *  |            | ||    |   |   |  |   |   |   ``=#==#====#=====||        | *
 *   `----------'  ||    |   |   |  |   |   |      |__|          `|        | *
 *    | | ``=| |===``    `--,',--`  `--,',--`      /||\            `------'  *
 **   \_/    \_/         / /   \ \  / /   \ \     //||\\           |_|  |_| **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Алгоритмы</h3>
Алгоритм — такое хитроумное название для последовательности совершаемых действий.
<br><br>
Структуры данных реализованы с помощью алгоритмов, алгоритмы — с помощью структур данных. Всё состоит из структур данных и алгоритмов, вплоть до уровня, на котором бегают микроскопические человечки с перфокартами и заставляют компьютер работать. (Ну да, у Интела в услужении микроскопические люди. Поднимайся, народ!)
<br><br>
Любая данная задача реализуется бесконечным количеством способов. Как следствие, для решения распространённых задач изобрели множество различных алгоритмов.
<br><br>
Например, для сортировки неупорядоченного множества элементов существует до смешного большое количество алгоритмов:
<br><br>
<blockquote>
Сортировка вставками, Сортировка выбором, Сортировка слиянием, Сортировка пузырьком, Cортировка кучи, Быстрая сортировка, Сортировка Шелла, Сортировка Тима, Блочная сортировка, Поразрядная сортировка...</blockquote>
Некоторые из них значительно быстрее остальных. Другие занимают меньше памяти. Третьи легко реализовать. Четвёртые построены на допущениях относительно наборов данных.
<br><br>
Каждая из сортировок подходит лучше других для определённой задачи. Поэтому вам надо будет сперва решить, какие у вас потребности и критерии, чтобы понять, как сравнивать алгоритмы между собой.
<br><br>
Для сравнения производительности алгоритмов используется грубое измерение средней производительности и производительности в худшем случае, для обозначения которых используется термин «О» большое.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *           a           b                                 d                 *
 *           a         b    O(N^2)                      d                    *
 *     O(N!) a        b                O(N log N)    d                    c  *
 *           a      b                            d                 c         *
 *          a      b                          d             c        O(N)    *
 *          a    b                         d         c                       *
 *          a  b                       d      c                              *
 *         a  b                     d  c                                     *
 *         ab                   c                          O(1)              *
 *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *
 *      ba        c      d                                                   *
 *    ba   c        d                       f    f    f    f    f    f    f  *
 ** cadf    f d    f    f    f    f    f       O(log N)                     **
\*** ===================================================================== ***/
</pre>
</code>
<h3>О большое</h3>
«О» большое — обозначение способа приблизительной оценки производительности алгоритмов для относительного сравнения.
<br><br>
О большое — заимствованное информатикой математические обозначение, определяющее, как алгоритмы соотносятся с передаваемым им некоторым количеством N данных.
<br><br>
О большое характеризует две основные величины:
<br><br>
<b>Оценка времени выполнения</b> — общее количество операций, которое алгоритм проведёт на данном множестве данных.
<br>
<b>Оценка объёма</b> — общее количество памяти, требующееся алгоритму для обработки данного множества данных.
<br><br>
Оценки делаются независимо друг от друга: одни алгоритмы могут производить меньше операций, чем другие, занимая при этом больше памяти. Определив свои требования, вы сможете выбрать соответствующий алгоритм.
<br><br>
Вот некоторые распространённые значения О большого:
<br><br>
<source>
Имя               Нотация    Что вы скажете, припрись они к вам на вечеринку
----------------------------------------------------------------------------
Константная       O(1)         ОХРЕНЕННО!!
Логарифмическая   O(log N)     КРУТО!
Линейная          O(N)         НОРМАС.
Линейно-
логарифмическая   O(N log N)   БЛИИИН...
Полиномиальная    O(N ^ 2)     ОТСТОЙ
Экспоненциальная  O(2 ^ N)     ОТВРАТИТЕЛЬНО
Факториальная     O(N!)        ТВОЮЖМАТЬ</source>
Чтобы дать представление, о каких порядках чисел мы говорим, давайте взглянем, что это будут за значения в зависимости от N.
<br><br>
<source>
           N = 5            10             20             30
-----------------------------------------------------------------------
O(1)           1            1              1              1
O(log N)       2.3219...    3.3219...      4.3219...      4.9068...
O(N)           5            10             20             30
O(N log N)     11.609...    33.219...      84.638...      147.204...
O(N ^ 2)       25           100            400            900
O(2 ^ N)       32           1024           1,048,576      1,073,741,824
O(N!)          120          3,628,800      2,432,902,0... 265,252,859,812,191,058,636,308,480,000,000
</source>
Как видите, даже при относительно небольших числах можно сделать *дофига* дополнительной работы.
<br><br>
Структуры данных позволяют производить 4 основных типа действий: доступ, поиск, вставку и удаление.
<br><br>
Замечу, что структуры данных могут быть хороши в одном из действий, но плохи в другом.
<br><br>
<source>
                          Доступ      Поиск       Вставка      Удаление
------------------------------------------------------------------------
                Массив    O(1)        O(N)        O(N)         O(N)
        Связный список    O(N)        O(N)        O(1)         O(1)
Двоичное дерево поиска    O(log N)    O(log N)    O(log N)     O(log N)
</source>
Или даже...
<br><br>
<source>
                          Доступ       Поиск      Вставка      Удаление
------------------------------------------------------------------------
                Массив    ОХРЕНЕННО    НОРМАС     НОРМАС       НОРМАС
        Связный список    НОРМАС       НОРМАС     ОХРЕНЕННО    ОХРЕНЕННО
Двоичное дерево поиска    КРУТО        КРУТО      КРУТО        КРУТО</source>
Кроме того, некоторые действия имеют разную «среднюю» производительность и производительность в «самом худшем случае».
<br><br>
Идеальной структуры данных не существует. Вы выбираете самую подходящую, основываясь на данных и на том, как они будут обрабатываться. Чтобы сделать правильный выбор, важно знать различные распространённые структуры данных.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                             _.-..                                         *
 *                           ,'9 )\)`-.,.--.                                 *
 *                           `-.|           `.                               *
 *                              \,      ,    \)                              *
 *                               `.  )._\   (\                               *
 *                                |//   `-,//                                *
 *                                ]||    //"                                 *
 **                        hjw    ""    ""                                  **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Память</h3>
Компьютерная память — довольно скучная штука. Это группа упорядоченных слотов, в которых хранится информация. Чтобы получить к ней доступ, вы должны знать её адрес в памяти.
<br><br>
Фрагмент памяти можно представить так:
<br><br>
<code>
<pre>
Значения: |1001|0110|1000|0100|0101|1010|0010|0001|1101|1011...
  Адреса: 0    1    2    3    4    5    6    7    8    9    ...
</pre>
</code>
Если вы задумывались, почему в языках программирования отсчёт начинается с 0 — потому, что так работает память. Чтобы прочитать первый фрагмент памяти, вы читаете с 0 до 1, второй — с 1 до 2. Адреса этих фрагментов соответственно равны 0 и 1.
<br><br>
Конечно же, в компьютере больше памяти, чем показано в примере, однако её устройство продолжает принцип рассмотренного шаблона.
<br><br>
Просторы памяти — как Дикий Запад. Каждая работающая на компьютере программа хранится внутри одной и той же *физической* структуры данных. Использование памяти — сложная задача, и для удобной работы с ней существуют дополнительные уровни абстракции.
<br><br>
Абстракции имеют два дополнительных назначения:
<br><br>
- Сохраняют данные в памяти таким образом, чтобы с ними было эффективно и/или быстро работать.
<br>
- Сохраняют данные в памяти так, чтобы их было проще использовать.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                  *     _______________________                            *
 *                    ()=(_______________________)=()           *            *
 *       *                |                     |                            *
 *                        |   ~ ~~~~~~~~~~~~~   |       *               *    *
 *             *          |                     |                            *
 *   *                    |   ~ ~~~~~~~~~~~~~   |         *                  *
 *                        |                     |                            *
 *                        |   ~ ~~~~~~~~~~~~~   |                 *          *
 *        *               |                     |                            *
 *                   *    |_____________________|         *        *         *
 *                    ()=(_______________________)=()                        *
 **                                                                         **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Списки</h3>
Для начала реализуем список, чтобы показать сложности взаимодействия между памятью и структурой данных.
<br><br>
Список — представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз.
<br><br>
Начнём с пустого блока памяти, представленного обычным JavaScript-массивом. Также нам понадобится хранить значение длины списка.
<br><br>
Заметьте, что мы хотим хранить длину отдельно, поскольку в реальности у «памяти» нет значения length, которое можно было бы взять и прочитать.
<br><br>
<source lang="JavaScript">
class List {

    constructor() {
        this.memory = [];
        this.length = 0;
    }

    //...
}</source>
Первым делом нужно получать данные из списка. Обычный список позволяет очень быстро получить доступ к памяти, поскольку вы уже знаете нужный адрес.
<br><br>
Сложность операции доступа в список — O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
get(address) {
    return this.memory[address];
}
</source>
У списков есть порядковые номера, поэтому можно вставлять значения в начало, середину и конец.
<br><br>
Мы сфокусируемся на добавлении и удалении значений в начало или конец списка. Для этого понадобятся 4 метода:
<ul>
    <li><b>Push</b>    — Добавить значение в конец.</li>
    <li><b>Pop</b>     — Удалить значение из конца.</li>
    <li><b>Unshift</b> — Добавить значение в начало.</li>
    <li><b>Shift</b>   — Удалить значение из начала.</li>
</ul>
Начнём с операции «push» — реализуем добавление элементов в конец списка.
<br><br>
Это настолько же легко, как добавить значение в адрес, следующий за нашим списком. Поскольку мы храним длину, вычислить адрес — проще простого. Добавим значение и увеличим длину.
<br><br>
Добавление элемента в конец списка — константа O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
push(value) {
    this.memory[this.length] = value;
    this.length++;
}
</source>
Далее, реализуем метод «pop», убирающий элемент из конца нашего списка. Аналогично push, всё, что нужно сделать — убрать значение из последнего адреса. Ну, и уменьшить длину.
<br><br>
Удаление элемента из конца списка — константа O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
pop() {
    // Нет элементов — ничего не делаем.
    if (this.length === 0) return;

    // Получаем последнее значение, перестаём его хранить, возвращаем его.
    var lastAddress = this.length - 1;
    var value = this.memory[lastAddress];
    delete this.memory[lastAddress];
    this.length--;

    // Возвращаем значение, чтобы его можно было использовать.
    return value;
}
</source>
<br><br>
«Push» и «pop» работают с концом списка, и в общем-то являются простыми операциями, поскольку не затрагивают весь остальной список.
<br><br>
Давайте посмотрим, что происходит, когда мы работаем с началом списка, с операциями «unshift» и «shift».
<br><br>
Чтобы добавить новый элемент в начало списка, нужно освободить пространство для этого значения, сдвинув на один все последующие значения.
<br><br>
<code>
<pre>
[a, b, c, d, e]
 0  1  2  3  4
  ⬊  ⬊  ⬊  ⬊  ⬊
    1  2  3  4  5
[x, a, b, c, d, e]
</pre>
</code>
Чтобы сделать такой сдвиг, нужно пройтись по каждому из элементов и поставить на его место предыдущий.
<br><br>
Поскольку мы вынуждены пройтись по каждому из элементов списка:
<br><br>
Добавление элемента в начало списка — линейно O(N) — «НОРМАС.»
<br><br>
<source lang="JavaScript">
unshift(value) {
    // Cохраняем значение, которое хотим добавить в начало.
    var previous = value;

    // Проходимся по каждому элементу...
    for (var address = 0; address < this.length; address++) {
        // заменяя текущее значение «current» на предыдущее значение «previous»,
        // и сохраняя значение «current» для следующей итерации.
        var current = this.memory[address];
        this.memory[address] = previous;
        previous = current;
    }

    // Добавляем последний элемент на новую позицию в конце списка.
    this.memory[this.length] = previous;
    this.length++;
}
</source>
Осталось написать функцию сдвига списка в противоположном направлении — shift.
<br><br>
Мы удаляем первое значение и затем сдвигаем каждый элемент списка на предшествующий адрес.
<br><br>
<code>
<pre>
[x, a, b, c, d, e]
    1  2  3  4  5
  ⬋  ⬋  ⬋  ⬋  ⬋
 0  1  2  3  4
[a, b, c, d, e]
</pre>
</code>
Удаление элемента из начала списка — линейно O(N) — «НОРМАС.»
<br><br>
<source lang="JavaScript">
shift() {
    // Нет элементов — ничего не делаем.
    if (this.length === 0) return;

    var value = this.memory[0];

    // Проходимся по каждому элементу, кроме последнего
    for (var address = 0; address < this.length - 1; address++) {
        // и заменяем его на следующий элемент списка.
        this.memory[address] = this.memory[address + 1];
    }

    // Удаляем последний элемент, поскольку значение теперь в предыдущем адресе.
    delete this.memory[this.length - 1];
    this.length--;

    return value;
}
</source>
Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними. Однако, как мы увидели, для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти.
<br><br>
Давайте посмотрим на иную структуру данных и её методы по добавлению, доступу и удалению значений без необходимости знать адреса элементов.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                           ((\                                             *
 *     (              _  ,-_  \ \                                            *
 *     )             / \/  \ \ \ \                                           *
 *     (            /)| \/\ \ \| |          .'---------------------'.        *
 *     `~()_______)___)\ \ \ \ \ |        .'                         '.      *
 *                 |)\ )  `' | | |      .'-----------------------------'.    *
 *                /  /,          |      '...............................'    *
 *        ejm     |  |          /         \   _____________________   /      *
 *                \            /           | |_)                 (_| |       *
 *                 \          /            | |                     | |       *
 *                  )        /             | |                     | |       *
 **                /       /              (___)                   (___)     **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Хеш-таблицы</h3>
Хеш-таблица — неупорядоченная структура данных. Вместо индексов мы работаем с «ключами» и «значениями», вычисляя адрес памяти по ключу.
<br><br>
Смысл в том, что ключи «хешируются» и позволяют эффективно работать с памятью — добавлять, получать, изменять и удалять значения.
<br><br>
<source lang="JavaScript">
var hashTable = new HashTable();

hashTable.set('myKey', 'myValue');
hashTable.get('myKey'); // >> 'myValue'
</source>
Вновь используем обычный JavaScript-массив, представляющий память.
<br><br>
<source lang="JavaScript">
class HashTable {

    constructor() {
        this.memory = [];
    }

    // ...
}
</source>
Чтобы сохранять пары ключ-значение из хеш-таблицы в память, нужно превращать ключи в адреса. Этим занимается операция «хеширования».
<br><br>
Она принимает на вход ключ и преобразовывает его в уникальное число, соответствующее этому ключу.
<br><br>
<source lang="JavaScript">
hashKey("abc") =>  96354
hashKey("xyz") => 119193
</source>
Такая операция требует осторожности. Если ключ слишком большой, он будет сопоставляться несуществующему адресу в памяти.
<br><br>
Следовательно, хеш-функция должна ограничивать размер ключей, т.е. ограничивать число доступных адресов памяти для неограниченного количества значений.
<br><br>
Любая реализация хеш-таблиц сталкивается с этой проблемой.
<br><br>
Однако, поскольку мы собираемся рассмотреть лишь устройство их работы, предположим, что коллизий не случится.
<br><br>
Давайте определим функцию «hashKey».
<br><br>
Не вдавайтесь во внутреннюю логику, просто поверьте, что она принимает на вход строку и возвращает (практически всегда) уникальный адрес, который мы будем использовать в остальных функциях.
<br><br>
<source lang="JavaScript">
hashKey(key) {
    var hash = 0;
    for (var index = 0; index < key.length; index++) {
          // Ма-а-а-агия.
          var code = key.charCodeAt(index);
        hash = ((hash << 5) - hash) + code | 0;
    }
    return hash;
}
</source>
Теперь определим функцию «get», получающую значение по ключу.
<br><br>
Сложность чтения значения из хеш-таблицы — константа O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
get(key) {
    // Сперва получим адрес по ключу.
    var address = this.hashKey(key);
    // Затем просто вернём значение, находящееся по этому адресу.
    return this.memory[address];
}
</source>
Перед тем, как получать данные, неплохо бы их сперва добавить. В этом нам поможет функция «set».
<br><br>
Сложность установки значения в хеш-таблицу — константа O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
set(key, value) {
    // И вновь начинаем с превращения ключа в адрес.
    var address = this.hashKey(key);
    // Затем просто записываем значение по этому адресу.
    this.memory[address] = value;
}
</source>
Наконец, нужен способ удалять значения из хеш-таблицы. Сложность удаления значения из хеш-таблицы — константа O(1) — «ОХРЕНЕННО!!»
<br><br>
<source lang="JavaScript">
remove(key) {
    // Как обычно, хешируем ключ, получая адрес.
    var address = this.hashKey(key);
    // Удаляем значение, если оно существует.
    if (this.memory[address]) {
        delete this.memory[address];
    }
}</source>
<code>
<pre>
============================================================================
,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
============================================================================
</pre>
</code>
Теперь мы прекратим работать с памятью напрямую: все последующие структуры данных будут реализовываться через другие структуры данных.
<br><br>
Новые структуры фокусируются на двух вещах:
<ul>
    <li>Организовывают данные, исходя из особенностей их применения</li>
    <li>Абстрагируют детали реализации</li>
</ul>
Цель таких структур данных — организовать информацию для применения в программах различного типа. Они предоставляют язык, позволяющий выражать более сложную логику. При этом абстрагируются детали реализации, т.е. можно изменить реализацию, сделав её быстрее.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                             _ . - - -- .. _                               *
 *         ||||            .-'      /```\     `'-_             /|            *
 *         ||||           (     /`` \___/ ```\    )           | |            *
 *         \__/           |`"-//..__     __..\\-"`|           | |            *
 *          ||            |`"||...__`````__...||"`|           | |            *
 *          ||            |`"||...__`````__...||"`|           \ |            *
 *          ||       _,.--|`"||...__`````__...||"`|--.,_       ||            *
 *          ||    .'`     |`"||...__`````__...||"`|     `'.    ||            *
 *          ||   '.        `/ |...__`````__...| \         .'   ||            *
 *          ||     `'-..__  ``      `````      ``  __..-'`     ||            *
 *                        `""---,,,_______,,,---""`                          *
 **                                                                         **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Стеки</h3>
Стеки похожи на списки. Они также упорядочены, но ограничены в действиях: можно лишь добавлять и убирать значения из конца списка. Как мы увидели ранее, это происходит очень быстро, если обращаться к памяти напрямую.
<br><br>
Однако стеки могут быть реализованы через другие структуры данных, чтобы получить дополнительную функциональность.
<br><br>
Наиболее общий пример использования стеков — у вас есть один процесс, добавляющий элементы в стек и второй, удаляющий их из конца — приоритизируя недавно добавленные элементы.
<br><br>
Нам вновь понадобится JavaScript-массив, но на этот раз он символизирует не память, а список, вроде реализованного выше.
<br><br>
<source lang="JavaScript">
class Stack {

    constructor() {
        this.list = [];
        this.length = 0;
    }

    // ...
}</source>
Нам понадобится реализовать два метода, функционально идентичных методам списка — «push» и «pop».
<br><br>
Push добавляет элементы на верхушку стека.
<br><br>
<source lang="JavaScript">
push(value) {
    this.length++;
    this.list.push(value);
}
</source>
<br><br>
Pop удаляет элементы из верхушки.
<br><br>
<source lang="JavaScript">
pop() {
    // Нет элементов — ничего не делаем.
    if (this.length === 0) return;

    // Возьмём последний элемент списка и вернём значение.
    this.length--;
    return this.list.pop();
}
</source>
Кроме того, добавим функцию peek, показывающую элемент на верхушке стека без его удаления. Прим. переводчика: peek – взглянуть.
<br><br>
<source lang="JavaScript">
peek() {
    // Возвращаем последний элемент, не удаляя его.
    return this.list[this.length - 1];
}
</source>
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                   /:""|                     ,@@@@@@.                      *
 *                  |: oo|_                   ,@@@@@`oo                      *
 *                  C     _)                  @@@@C   _)                     *
 *                    ) /                     "@@@@ '=                       *
 *                   /`\\                      ```)/                         *
 *                  || | |                       /`\\                        *
 *                  || | |                      || | \                       *
 *                  ||_| |                      || | /                       *
 *                  \( ) |                      ||_| |                       *
 *               |~~~`-`~~~|                    |))) |                       *
 *         (_)   |         |         (_)        |~~~/          (_)           *
 *         | |`""....__     __....""`| |`""...._|| /  __....""`| |           *
 *         | |`""....__`````__....""`| |`""....__`````__....""`| |           *
 *         | |       | ||```         | |        ||`|``         | |           *
 *         | |       |_||__          | |        ||_|__         | |           *
 *        ,| |, jgs  (____))        ,| |,       ((;:;:)       ,| |,          *
 **       `---`                     `---`                     `---`         **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Очереди</h3>
Теперь создадим очередь — структуру, комплементарную стеку. Разница в том, что элементы очереди удаляются из начала, а не из конца, т.е. сначала старые элементы, потом новые.
<br><br>
Как уже оговаривалось, поскольку функциональность ограничена, существуют разные реализации очереди. Хорошим способом будет использование связного списка, о котором мы поговорим чуть позже.
<br><br>
И вновь мы призываем на помощь JavaScript-массив! В случае с очередью мы опять рассматриваем его как список, а не как память.
<br><br>
<source lang="JavaScript">
class Queue {

    constructor() {
        this.list = [];
        this.length = 0;
    }

    // ...
}
</source>
Аналогично стекам мы определяем две функции для добавления и удаления элементов из очереди.
<br><br>
Первым будет «enqueue» — добавление элемента в конец списка.
<br><br>
<source lang="JavaScript">
enqueue(value) {
    this.length++;
    this.list.push(value);
}
</source>
<br><br>
Далее — «dequeue». Элемент удаляется не из конца списка, а из начала.
<br><br>
<source lang="JavaScript">
dequeue() {
    // Нет элементов — ничего не делаем.
    if (this.length === 0) return;

    // Убираем первый элемент методом shift и возвращаем значение.
    this.length--;
    return this.list.shift();
}
</source>
Аналогично стекам объявим функцию «peek», позволяющую получить значение в начале очереди без его удаления.
<br><br>
<source lang="JavaScript">
peek() {
    return this.list[0];
}
</source>
Важно заметить, что, поскольку для реализации очереди использовался список, она наследует линейную производительность метода shift (т.е. O(N) — «НОРМАС.»).
<br><br>
Как мы увидим позже, связные списки позволяют реализовать более быструю очередь.
<br><br>
<code>
<pre>
============================================================================
,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
============================================================================
</pre>
</code>
С этого места и далее мы будем работать со структурами данных, где значения ссылаются друг на друга.
<br><br>
<source>
+- Структура данных -------------------------------------+
|  +- Элемент A ------------+ +- Элемент B ------------+ |
|  | Значение: 1            | | Значение: 2            | |
|  | Ссылка на: (Элемент B) | | Ссылка на: (Элемент A) | |
|  +------------------------+ +------------------------+ |
+--------------------------------------------------------+
</source>
Элементы структуры данных становятся сами по себе министруктурами, содержащими значение и дополнительную информацию — ссылки на другие элементы родительской структуры.
<br><br>
Сейчас вы поймёте, что я имею ввиду.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                                                                           *
 *   |                                 RICK ASTLEY'S NEVER GONNA...          *
 *   |       +-+                                                             *
 *   |  +-+  |-|                          [^] - GIVE YOU UP                  *
 *   |  |^|  |-|                 +-+      [-] - LET YOU DOWN                 *
 *   |  |^|  |-|       +-+       |*|      [/] - RUN AROUND AND DESERT YOU    *
 *   |  |^|  |-|  +-+  |\|       |*|      [\] - MAKE YOU CRY                 *
 *   |  |^|  |-|  |/|  |\|  +-+  |*|      [.] - SAY GOODBYE                  *
 *   |  |^|  |-|  |/|  |\|  |.|  |*|      [*] - TELL A LIE AND HURT YOU      *
 *   |  |^|  |-|  |/|  |\|  |.|  |*|                                         *
 *   +--------------------------------                                       *
 **                                                                         **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Графы</h3>
На самом деле граф — совсем не то, о чём вы подумали, увидев ascii-график.
<br><br>
Граф — структура наподобие этой:
<br><br>
<img src="https://habrastorage.org/files/e08/a1c/478/e08a1c478652497ca4f0c26356506b43.png"/>
<br><br>
У нас есть множество «вершин» (A, B, C, D, ...), связанных линиями.
<br><br>
Эти вершины можно представить вот так:
<br><br>
<source lang="JavaScript">
Node {
    value: ...,
    lines: [(Node), (Node), ...]
}
</source>
А весь граф будет выглядеть вот так:
<br><br>
<source lang="JavaScript">
Graph {
    nodes: [
        Node {...},
        Node {...},
        ...
    ]
}
</source>
Представим список вершин JavaScript-массивом. Массив используется не с целью специально упорядочить вершины, а как место для хранения вершин.
<br><br>
<source lang="JavaScript">
class Graph {

    constructor() {
        this.nodes = [];
    }

    // ...
}
</source>
<br><br>
Начнём добавлять значения в граф, создавая вершины без каких-либо линий.
<br><br>
<source lang="JavaScript">
addNode(value) {
    this.nodes.push({
        value: value,
        lines: []
    });
}
</source>
Теперь нужен способ искать вершины в графе. Обычно для ускорения поиска делается ещё одна структура данных поверх графа.
<br><br>
Но в нашем случае мы просто переберём все вершины, чтобы найти соответствующую значению. Способ медленный, но работающий.
<br><br>
<source lang="JavaScript">
find(value) {
    return this.nodes.find(function(node) {
        return node.value === value;
    });
}
</source>
Теперь мы можем связать две вершины, проведя «линию» от одной до другой (прим. переводчика: дугу графа).
<br><br>
<source lang="JavaScript">
addLine(startValue, endValue) {
    // Найдём вершины для каждого из значений.
    var startNode = this.find(startValue);
    var endNode = this.find(endValue);

    // Ругнёмся, если не нашли одной или другой.
    if (!startNode || !endNode) {
        throw new Error('Обе вершины должны существовать');
    }

    // В стартовую вершину startNode добавим ссылку на конечную вершину endNode.
    startNode.lines.push(endNode);
}
</source>
Полученный граф можно использовать вот так:
<br><br>
<source lang="JavaScript">
var graph = new Graph();
graph.addNode(1);
graph.addNode(2);
graph.addLine(1, 2);
var two = graph.find(1).lines[0];
</source>
<br><br>
Кажется, что для такой мелкой задачи сделано слишком много работы, однако это мощный паттерн.
<br><br>
Он часто применяется для поддержания прозрачности в сложных программах. Это достигается оптимизацией взаимосвязей между данными, а не операций над самими данными. Если вы выберете одну вершину в графе, невероятно просто найти связанные с ней элементы.
<br><br>
Графами можно представлять уйму вещей: пользователей и их друзей, 800 зависимостей в папке node_modules, даже сам интернет, являющийся графом связанных друг с другом ссылками веб-страниц.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *      _______________________                                              *
 *  ()=(_______________________)=()              ,-----------------,_        *
 *      |                     |               ,"                      ",     *
 *      |   ~ ~~~~~~~~~~~~~   |             ,'    ,---------------,     `,   *
 *      |               ,----------------------------,          ,----------- *
 *      |   ~ ~~~~~~~~ |                              |        |             *
 *      |               `----------------------------'          `----------- *
 *      |   ~ ~~~~~~~~~~~~~   |            `,    `----------------'     ,'   *
 *      |                     |              `,                      ,'      *
 *      |_____________________|                 `------------------'         *
 *  ()=(_______________________)=()                                          *
 **                                                                         **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Связные списки</h3>
Давайте теперь посмотрим, как графоподобная структура может оптимизировать упорядоченный список данных.
<br><br>
Связные списки — распространённая структура данных, зачастую используемая для реализации других структур. Преимущество связного списка — эффективность добавления элементов в начало, середину и конец.
<br><br>
Связный список по своей сути похож на граф: вы работаете с вершинами, указывающими на другие вершины. Они расположены таким образом:
<br><br>
<code>
<pre>
1 -> 2 -> 3 -> 4 -> 5
</pre>
</code>
Если представить эту структуру в виде JSON, получится нечто такое:
<br><br>
<source lang="JavaScript">
{
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {...}
        }
    }
}
</source>
<br><br>
В отличие от графа, связный список имеет единственную вершину, из которой начинается внутренняя цепочка. Её называют «головой», головным элементом или первым элементом связного списка.
<br><br>
Также мы собираемся отслеживать длину списка.
<br><br>
<source lang="JavaScript">
class LinkedList {

    constructor() {
        this.head = null;
        this.length = 0;
    }

    // ...
}
</source>
<br><br>
Первым делом нужен способ получать значение по данной позиции.
<br><br>
В отличие от обычных списков мы не можем перепрыгнуть на нужную позицию. Вместо этого мы должны перейти к ней через отдельные вершины.
<br><br>
<source lang="JavaScript">
get(position) {
    // Выведем ошибку, если искомая позиция превосходит число вершин в списке.
    if (position >= this.length) {
        throw new Error('Позиция выходит за пределы списка');
    }

    // Начнём с головного элемента списка.
    var current = this.head;

    // Пройдём по всем элементам при помощи node.next,
    // пока не достигнем требуемой позиции.
    for (var index = 0; index < position; index++) {
        current = current.next;
    }

    // Вернём найденную вершину.
    return current;
}
</source>
<br><br>
Теперь необходим способ добавлять вершины в выбранную позицию.
<br><br>
Создадим метод add, принимающий значение и позицию.
<br><br>
<source lang="JavaScript">
add(value, position) {
    // Сначала создадим вершину, содержащую значение.
    var node = {
        value: value,
        next: null
    };

    // Нужно обработать частный случай, когда вершина вставляется в начало.
    // Установим поле «next» в текущий головной элемент и заменим
    // головной элемент нашей вершиной.
    if (position === 0) {
        node.next = this.head;
        this.head = node;

    // Если мы добавляем вершину на любую другую позицию, мы должны вставить её
    // между текущей вершиной current и предыдущей previous.
    } else {
          // Сперва найдём предыдущую и текущую вершины.
          var prev = this.get(position - 1);
          var current = prev.next;
          // Затем вставим новую вершину между ними, установив поле «next»
          // на текущую вершину current,
          // и поле «next» предыдущей вершины previous — на вставляемую.
          node.next = current;
          prev.next = node;
    }

    // И увеличим длину.
    this.length++;
}
</source>
<br><br>
Последний метод, который нам понадобится — remove. Найдём вершину по позиции и выкинем её из цепочки.
<br><br>
<source lang="JavaScript">
remove(position) {
    // Если мы удаляем головной элемент, просто переставим указатель head
    // на следующую вершину.
    if (position === 0) {
        this.head = this.head.next;

    // Для остальных случаев требуется найти предыдущую вершину и поставить
    // в ней ссылку на вершину, следующую за текущей.
    } else {
        var prev = this.get(position - 1);
        prev.next = prev.next.next;
    }

    // И затем уменьшим длину.
    this.length--;
}
</source>
<br><br>
<code>
<pre>
============================================================================
,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
============================================================================
</pre>
</code>
<br><br>
Две оставшиеся структуры данных относятся к семейству «деревьев».
<br><br>
Как и в жизни, существует множество различных древовидных структур данных.
<br><br>
Прим. переводчика: ну не-е-е-е, я пас...
<br><br>
Binary Trees:<br>
AA Tree, AVL Tree, Binary Search Tree, Binary Tree, Cartesian Tree, left child/right sibling tree, order statistic tree, Pagoda, ...
<br><br>
B Trees:<br>
B Tree, B+ Tree, B* Tree, B Sharp Tree, Dancing Tree, 2-3 Tree, ...
<br><br>
Heaps:<br>
Heap, Binary Heap, Weak Heap, Binomial Heap, Fibonacci Heap, Leonardo Heap, 2-3 Heap, Soft Heap, Pairing Heap, Leftist Heap, Treap, ...
<br><br>
Trees:<br>
Trie, Radix Tree, Suffix Tree, Suffix Array, FM-index, B-trie, ...
<br><br>
Multi-way Trees:<br>
Ternary Tree, K-ary tree, And-or tree, (a,b)-tree, Link/Cut Tree, ...
<br><br>
Space Partitioning Trees:<br>
Segment Tree, Interval Tree, Range Tree, Bin, Kd Tree, Quadtree, Octree, Z-Order, UB-Tree, R-Tree, X-Tree, Metric Tree, Cover Tree, ...
<br><br>
Application-Specific Trees:<br>
Abstract Syntax Tree, Parse Tree, Decision Tree, Minimax Tree, ...
<br><br>
Чего уж вы не ожидали, так это что будете изучать сегодня дендрологию… И это ещё не все деревья. Пусть они вас не смущают, большинство из них вообще не имеет смысла. Надо же было людям как-то защищать кандидатские степени и что-то для этого доказывать.
<br><br>
Деревья похожи на графы или связные списки, с той разницей, что они «однонаправленые». Это значит, что в них не может существовать циклических ссылок.
<br><br>
<img src="https://habrastorage.org/files/b8a/de1/837/b8ade18377db40009837abe1bc9027d9.png"/>
<br><br>
Если вы можете пройти круг по вершинам дерева... что ж, поздравляю, но это не дерево.
<br><br>
Деревья применяются во множестве задач. Они используются для оптимизации поиска или сортировки. Они могут лучше организовывать программу. Они могут создать представление, с которым проще работать.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *            ccee88oo             \ | /                                     *
 *          C8O8O8Q8PoOb o8oo    '-.;;;.-,   ooooO8O8QOb o8bDbo              *
 *        dOB69QO8PdUOpugoO9bD  -==;;;;;==-aadOB69QO8PdUOpugoO9bD            *
 *       CgggbU8OU qOp qOdoUOdcb .-';;;'-.  CgggOU ddqOp qOdoUOdcb           *
 *           6OuU  /p u gcoUodpP   / | \ jgs  ooSec cdac pdadfoof            *
 *             \\\//  /douUP         '         \\\d\\\dp/pddoo               *
 *               \\\////                         \\ \\////                   *
 *                |||/\                           \\///                      *
 *                |||\/                           ||||                       *
 *                |||||                          /|||                        *
 ** .............//||||\.......................//|||\\..................... **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Деревья</h3>
Начнём с простой древовидной структуры. В ней нет особых правил, и выглядит она примерно так:
<br><br>
<source lang="JavaScript">
Tree {
    root: {
        value: 1,
        children: [{
            value: 2,
            children: [...]
        }, {
            value: 3,
            children: [...]
        }]
    }
}
</source>
<br><br>
Дерево должно начинаться с единственного родителя, «корня» дерева.
<br><br>
<source lang="JavaScript">
class Tree {

    constructor() {
        this.root = null;
    }

    // ...
}
</source>
<br><br>
Нам нужен способ обходить наше дерево и вызывать определённую функцию в каждой его вершине.
<br><br>
<source lang="JavaScript">
traverse(callback) {
    // Определим функцию обхода walk, которую можно рекурсивно вызывать
    // в каждой вершине дерева.
    function walk(node) {
        // Сперва вызовем callback на самой вершине.
        callback(node);
        // Затем рекурсивно вызовем walk на всех её потомках.
        node.children.forEach(walk);
    }

    // А теперь запустим процесс обхода.
    walk(this.root);
}
</source>
<br><br>
Теперь нужен способ добавлять вершины в дерево.
<br><br>
<source lang="JavaScript">
add(value, parentValue) {
    var newNode = {
        value: value,
        children: []
    };

    // Если корня не существует, установим в него новую вершину.
    if (this.root === null) {
        this.root = newNode;
        return;
    }

    // В остальных случаях переберём внутреннее дерево, найдём вершину
    // с соответствующим значением parentValue и добавим новую вершину
    // к его потомкам.
    this.traverse(function(node) {
        if (node.value === parentValue) {
            node.children.push(newNode);
        }
    });
}
</source>
<br><br>
Это простое дерево, возможно, полезное лишь в случае, когда отображаемые данные на него похожи.
<br><br>
Однако при наличии дополнительных правил деревья могут выполнять кучу различных задач.
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 * 0 0 1 0 1 0 0 1 0 1 1 1 0 1  ,@@@@@@@@@@@@@@,   0 0 1 0 1 0 0 1 0 1 1 1 0 *
 * 0 1 0 1 0 1 0 1 1 0 1 1 0  @@`              '@@   0 1 0 1 0 1 1 0 1 0 1 0 *
 * 1 1 0 0 0 1 0 0 1 1 1 0  @@`   8O8PoOb o8o    '@@   0 0 1 0 0 1 0 0 1 1 1 *
 * 0 0 1 1 0 1 0 1 0 0 0  @@   dOB69QO8PdUgoO9bD    @@   1 0 1 1 0 1 0 1 0 0 *
 * ===================== @@   CgbU8OU qOp qOdOdcb    @@  0 1 1 0 1 0 1 0 1 0 *
 *                       @@      6OU /p u gcoUpP     @@  1 0 1 1 0 1 0 0 1 1 *
 * ===================== @@         \\// /doP        @@  0 1 1 0 0 1 0 0 1 0 *
 * 1 1 0 0 1 1 0 1 1 0 0  @@         \\//           @@   1 0 1 0 0 1 1 0 1 1 *
 * 0 1 1 0 1 0 1 1 0 1 1 0  @@,      |||          ,@@  0 1 1 0 1 1 0 0 1 0 1 *
 * 1 0 1 0 1 1 0 0 1 0 0 1 0  @@,   //|\       ,@@   0 1 0 1 0 1 1 0 0 1 1 0 *
 **  1 0 1 0 0 1 1 0 1 0 1 0 1  `@@@@@@@@@@@@@@'   0 1 1 1 0 0 1 0 1 0 1 1  **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Двоичные деревья поиска</h3>
Двоичные деревья поиска — распространённая форма деревьев. Они умеют эффективно читать, искать, вставлять и удалять значения, сохраняя при этом отсортированный порядок.
<br><br>
Представьте, что у вас есть последовательность чисел:
<br><br>
<code>
<pre>
1  2  3  4  5  6  7
</pre>
</code>
Развернём её в дерево, начинающееся из центра.
<br><br>
<code>
<pre>
             4
          /     \
       2           6
     /   \       /   \
    1     3     5     7
   -^--^--^--^--^--^--^-
    1  2  3  4  5  6  7
</pre>
</code>
Вот пример, как работает бинарное дерево. У каждой вершины есть два потомка:
<ul>
    <li><b>Левый</b> - меньше, чем значение вершины-родителя.</li>
    <li><b>Правый</b> – больше, чем значение вершины-родителя.</li>
</ul>
Замечание: для того, чтобы это работало, все значения в дереве должны быть уникальны.
<br><br>
Это делает обход дерева при поиске значения очень эффективным. Например, попробуем найти число 5 в нашем дереве.
<br><br>
<code>
<pre>
            (4)         <--- 5 > 4, двигаемся направо.
          /     \
       2         (6)    <--- 5 < 6, двигаемся налево.
     /   \      /   \
    1     3    (5)   7  <--- Мы добрались до 5!
</pre>
</code>
Заметьте, чтобы добраться до 5, потребовалось сделать лишь 3 проверки. А если бы дерево состояло из 1000 элементов, путь был бы таким:
<br><br>
<code>
<pre>
500 -> 250 -> 125 -> 62 -> 31 -> 15 -> 7 -> 3 -> 4 -> 5
</pre>
</code>
Всего 10 проверок на 1000 элементов!
<br><br>
Ещё одной важной особенностью двоичных деревьев поиска является их схожесть со связными списками — при добавлении или удалении значения вам нужно обновлять лишь непосредственно окружающие элементы.
<br><br>
Как и в прошлой секции, сперва нужно установить “корень” двоичного дерева поиска.
<br><br>
<source lang="JavaScript">
class BinarySearchTree {

    constructor() {
        this.root = null;
    }

    // ...
}
</source>
<br><br>
Чтобы проверить, находится ли значение в дереве, нужно провести поиск по дереву.
<br><br>
<source lang="JavaScript">
contains(value) {
    // Начинаем с корня.
    var current = this.root;

    // Мы будем продолжать обход, пока есть вершины, которые можно посетить.
    // Если мы достигнем левой или правой вершин, равных null, цикл закончится.
    while (current) {

        // Если значение value больше current.value, двигаемся вправо.
        if (value > current.value) {
            current = current.right;

        // Если значение value меньше current.value, двигаемся влево.
        } else if (value < current.value) {
            current = current.left;

        // Иначе значения должны быть равны и мы возвращаем true.
        } else {
            return true;
        }
    }

    // Если мы не нашли ничего, возвращаем false.
    return false;
}
</source>
<br><br>
Чтобы добавить элемент в дерево, нужно произвести такой же обход, как и раньше, перепрыгивая по левым и правым вершинам в зависимости от того, больше или меньше ли они по сравнению с добавляемым значением.
<br><br>
Однако теперь, когда мы доберёмся до левой или правой вершины, равной null,
мы добавим вершину в эту позицию.
<br><br>
<source lang="JavaScript">
add(value) {
    // Для начала создадим вершину.
    var node = {
        value: value,
        left: null,
        right: null
    };

    // Частный случай, если не существует корневой вершины — добавим её.
    if (this.root === null) {
        this.root = node;
        return;
    }

    // Начнём обход с корня.
    var current = this.root;

    // Мы собираемся циклически продолжать работу до тех пор, пока не добавим
    // наш элемент или не обнаружим, что он уже находится в дереве.
    while (true) {

        // Если значение value больше current.value, двигаемся вправо.
        if (value > current.value) {

            // Если правая вершина не существует, установим её и закончим обход.
            if (!current.right) {
                current.right = node;
                break;
            }

            // Иначе перейдём на правую вершину и продолжим.
            current = current.right;

        // Если значение value меньше current.value, двигаемся влево.
        } else if (value < current.value) {

            // Если левая вершина не существует, установим её и закончим обход.
            if (!current.left) {
                current.left = node;
                break;
            }

            // Иначе перейдём на левую вершину и продолжим.
            current = current.left;

        // Если значение ни больше и не меньше, оно должно быть совпадать
        // с текущим, значит ничего делать не надо.
        } else {
            break;
        }
    }
}
</source>
<br><br>
<code>
<pre>

/*** ===================================================================== ***\
 *                                           .''.                            *
 *                 .''.             *''*    :_\/_:     .                     *
 *                :_\/_:   .    .:.*_\/_*   : /\ :  .'.:.'.                  *
 *            .''.: /\ : _\(/_  ':'* /\ *  : '..'.  -=:o:=-                  *
 *           :_\/_:'.:::. /)\*''*  .|.* '.\'/.'_\(/_'.':'.'                  *
 *           : /\ : :::::  '*_\/_* | |  -= o =- /)\    '  *                  *
 *            '..'  ':::'   * /\ * |'|  .'/.\'.  '._____                     *
 *                *        __*..* |  |     :      |.   |' .---"|             *
 *                 _*   .-'   '-. |  |     .--'|  ||   | _|    |             *
 *              .-'|  _.|  |    ||   '-__  |   |  |    ||      |             *
 *              |' | |.    |    ||       | |   |  |    ||      |             *
 * _____________|  '-'     '    ""       '-'   '-.'    '`      |____________ *
 ** jgs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **
\*** ===================================================================== ***/
</pre>
</code>
<h3>Конец</h3>
Надеюсь, вы получили хорошую дозу знаний. Если вам понравилось,
ставьте звездочки в репозитории и подписывайтесь на меня в твиттере.
<br><br>
Также можете прочитать другую мою статью, "The Super Tiny Compiler" https://github.com/thejameskyle/the-super-tiny-compiler
<br><br>
<source lang="JavaScript">
// Экспортируем модули для тестов...
module.exports = {
    List: List,
    HashTable: HashTable,
    Stack: Stack,
    Queue: Queue,
    Graph: Graph,
    LinkedList: LinkedList,
    Tree: Tree,
    BinarySearchTree: BinarySearchTree
};
</source>

<hr />
<br>
Также эту статью можно прочитать <a href="https://github.com/aalexeev239/itsy-bitsy-data-structures/">на гитхабе</a>.
<br><br>
Перевод: @aalexeev, редактура: @iamo0, Чайка Чурсина.

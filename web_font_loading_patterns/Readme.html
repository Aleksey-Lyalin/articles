Паттерны загрузки веб-шрифтов
<p><em>Вы читаете перевод статьи Bram Stein <a href="https://www.bramstein.com/writing/web-font-loading-patterns.html">Web Font Loading Patterns</a>.</em></p>

<hr />
<p><em>Загрузка веб-шрифтов может показаться сложной задачей. Однако, на самом деле, она довольно проста, если вы будете использовать описанные ниже паттерны. Комбинируя их, вы сможете управлять загрузкой веб-шрифтов во всех браузерах.</em></p>

<p>В этих паттернах используется <a href="https://github.com/bramstein/fontfaceobserver">Font Face Ob­server</a>, простая и небольшая библиотека загрузки веб-шрифтов. Font Face Ob­server выбирает наиболее эффективный способ загрузки шрифта, основываясь на его браузерной поддержке, так что мы можем загружать шрифты, не беспокоясь о кроссбраузерности.</p>

<ol>
    <li><a href="#ch1">Обычная загрузка шрифтов</a></li>
    <li><a href="#ch2">Загрузка группы шрифтов</a></li>
    <li><a href="#ch3">Загрузка шрифтов с таймером</a></li>
    <li><a href="#ch4">Приоритетная загрузка</a></li>
    <li><a href="#ch5">Особое отображение шрифтов</a></li>
    <li><a href="#ch6">Оптимизация для кэширования</a></li>
</ol>

<p>Невозможно посоветовать единый паттерн, который идеально подходил бы каждому. Внимательно изучите свой сайт, его аудиторию, и на основании этого выберите тот способ загрузки или их комбинацию, которые подойдут лучше всего.</p>

<h2><a id="ch1"></a>Обычная загрузка шрифтов</h2>

<p>Font Face Ob­server даёт вам возможность контролировать загрузку веб-шрифтов через простой интерфейс, основанный на промисах. Не имеет значения, откуда будут загружаться шрифты: вы можете размещать их как у себя, так и подключать через сервисы — <a href="https://www.google.com/fonts">Google Fonts</a>, <a href="https://typekit.com/">Type­kit</a>, <a href="https://fonts.com/">Fonts.com</a>, и <a href="http://www.webtype.com/">Web­type</a>.</p>

<p>Чтобы не перегружать паттерны лишним кодом, будем считать, что вы размещаете веб-шрифты у себя. Это означает, что в ваших CSS-файлах будет одно или несколько объявлений <code>@font-face</code>, в которых указано, какие шрифты нужно загрузить через Font Face Ob­server. Для краткости мы не будем объявлять каждое из подобных правил в коде, но будем считать, что они есть.</p>

<pre><code>@font-face {
font-family: Output Sans;
src: url(output-sans.woff2) format(&quot;woff2&quot;),
         url(output-sans.woff) format(&quot;woff&quot;);
}
</code></pre>

<p>Рассмотрим самую обычную задачу: вам надо загрузить один или несколько разных шрифтов. Создайте несколько экземпляров <code>FontFaceObserver</code>, по одному на каждый шрифт, и вызовите их метод <code>load</code>.</p>

<pre><code>var output = new FontFaceObserver('Output Sans');
var input = new FontFaceObserver('Input Mono');

output.load().then(function () {
console.log('Загружен Output Sans.');
});

input.load().then(function () {
console.log('Загружен Input Mono.');
});
</code></pre>

<p>Этот способ загрузит каждый шрифт независимо от остальных. Это полезно, когда шрифты не связаны друг с другом, и мы ожидаем, что они отрисуются постепенно (т.е. как только загрузятся, так и отрисуются). В отличие от стандартного <a href="https://www.w3.org/TR/css-font-loading/">API загрузки шрифтов</a> вы не передаёте URL шрифтов в Font Face Ob­server. Для загрузки шрифтов он использует объявления <code>@font-face</code>, уже доступные в CSS. Это позволяет загружать веб-шрифты вручную через JavaScript, предусмотрев постепенную деградацию к обычному CSS.</p>

<h2><a id="ch2"></a>Загрузка групп шрифтов</h2>

<p>Вы можете загружать несколько шрифтов одновременно, группируя их: вся группа либо загрузится полностью, либо выдаст ошибку. Это полезно использовать, когда загружаемые шрифты принадлежат к одному семейству, и вы не хотите, чтобы группа отрисовывалась, пока не загрузятся все шрифты из неё. Тем самым, браузер не будет отображать стили, пока шрифты представлены не полностью.</p>

<pre><code>var normal = new FontFaceObserver('Output Sans');
var italic = new FontFaceObserver('Output Sans', {
style: 'italic'
});

Promise.all([
normal.load(),
italic.load()
]).then(function () {
console.log('Загружено семейство Output Sans.');
});
</code></pre>

<p>Вы можете сгруппировать шрифты через <code>Promise.all</code>. Когда промис будет выполнен, мы будем знать, что все шрифты загружены. Если промис отклонён — как минимум один из шрифтов не смог загрузиться. </p>

<p>Ещё один пример применения группировки шрифтов — уменьшение количества перекомпоновок страницы. Если вы загружаете и отрисовываете веб-шрифты постепенно, браузер будет выполнять перекомпоновку страницы множество раз, так как характеристики начертаний запасного и веб-шрифта различны. Группировка позволит сократить количество перекомпоновок до одной.</p>

<h2><a id="ch3"></a>Загрузка шрифтов с таймером</h2>

<p>Иногда шрифты загружаются очень долго. Это может стать проблемой, поскольку веб-шрифты отвечают за текст — главную часть контента вашей страницы. Невозможно ждать загрузки шрифтов бесконечно. Мы можем исправить это, добавив таймер к загрузке.</p>

<p>Следующая вспомогательная функция создаёт таймеры, возвращающие промис, отклоняющийся по срабатыванию таймера.</p>

<pre><code>function timer(time) {
return new Promise(function (resolve, reject) {
    setTimeout(reject, time);
});
}
</code></pre>

<p>С помощью <code>Promise.race</code> мы можем заставить таймер и загрузку шрифта «соревноваться» друг с другом. Например, если загрузка завершилась до того, как сработал таймер, то шрифт победил, промис выполнен. А если раньше сработал таймер, промис отклонён.</p>

<pre><code>var font = new FontFaceObserver('Output Sans');

Promise.race([
timer(1000),
font.load()
]).then(function () {
console.log('Загружен Output Sans.');
}).catch(function () {
console.log('Время на загрузку Output Sans истекло.');
});
</code></pre>

<p>В этом примере время загрузки шрифта ограничено одной секундой. Вместо того, чтобы работать с одним шрифтом, мы также можем назначить таймер целой группе шрифтов. Это позволит просто и эффективно ограничить время их загрузки.</p>

<h2><a id="ch4"></a>Приоритетная загрузка</h2>

<p>Обычно, для того, чтобы отрисовать первую половину экрана (<em>“above the fold”</em> — верхняя половина первого экрана сайта, которую надо отобразить максимально быстро, <em>прим. переводчика</em>), нужно лишь несколько шрифтов. Если загружать эти шрифты раньше других, менее важных, мы получим выигрыш в производительности сайта. Это называется приоритетной загрузкой.</p>

<pre><code>var primary = new FontFaceObserver('Primary');
var secondary = new FontFaceObserver('Secondary');

primary.load().then(function () {
console.log('Загружен основной шрифт.')

secondary.load().then(function () {
    console.log('Загружен второстепенный шрифт.')
});
});
</code></pre>

<p>При использовании приоритетной загрузки второстепенный шрифт зависит от основного: если не загрузится основной шрифт, то не загрузится и второстепенный. Это может оказаться полезным.</p>

<p>Например, можно применить приоритетную загрузку так: сначала загрузить небольшой основной шрифт, содержащий ограниченное число символов, а затем полный шрифт с большим количеством символов или стилей. Так как основной шрифт мал, он намного быстрее загрузится и отрисуется. А если основной шрифт не смог загрузиться, то, вполне возможно, не следует запрашивать и второстепенный — скорее всего, он тоже не загрузится.</p>

<p>Такое использование приоритетной загрузки более подробно описано в статьях Zach Leatherman: <a href="https://www.zachleat.com/web/foft/">Flash of Faux Text</a> и <a href="https://www.zachleat.com/web/web-font-data-uris/">Web Font Anti-Pat­terns: Data URIs</a>.</p>

<h2><a id="ch5"></a>Особое отображение шрифтов</h2>

<p>Перед тем как браузер сможет показать веб-шрифт, он должен скачать его по сети. Обычно это занимает какое-то время, и каждый браузер по-разному ведёт себя во время скачивания веб-шрифтов: некоторые из них скрывают текст, а другие сразу же показывают его с помощью запасного шрифта. Обычно это называют <em>мельканием невидимого текста</em> (Flash Of In­vis­i­ble Text, <em>FOIT</em>) и <em>мельканием текста без стилей</em> (Flash Of Un­styled Text, <em>FOUT</em>).</p>

<p><img alt="FOUT и FOIT" src="https://github.com/aalexeev239/articles/raw/master/web_font_loading_patterns/img/fout-foit.png" /></p>

<p>In­ter­net Ex­plorer и Edge используют FOUT и отображают запасные шрифты, пока веб-шрифт не закончит свою загрузку. Все остальные браузеры используют FOIT и прячут текст во время загрузки веб-шрифтов.</p>

<p>Для управления этим поведением ввели новое CSS-свойство, называемое <code>font-display</code> (<a href="https://tabatkins.github.io/specs/css-font-display/">CSS Font Ren­der­ing Con­trols</a>). К сожалению, оно до сих пор находится в разработке и ещё не поддерживается ни одним браузером (на данный момент оно спрятано за флагом в Chrome и Opera). Однако мы можем реализовать аналогичное поведение во всех браузерах с помощью Font Face Ob­server.</p>

<p>Вы можете обмануть браузеры, использующие FOIT, заставив их сразу же отрисовывать текст запасными шрифтами, используя только полностью загруженные шрифты из вашей цепочки. Если шрифт ещё не в цепочке (поскольку он загружается), браузеры не будут пытаться скрыть текст.</p>

<p>Простейший способ сделать это — устанавливать на элемент <code>&lt;html&gt;</code> по классу на каждое из трёх состояний загрузки веб-шрифта: сам процесс загрузки, его завершение и ошибку. Класс <code>fonts-loading</code> устанавливается сразу, как начинается загрузка, <code>fonts-loaded</code> — когда шрифт загружен, и <code>fonts-failed</code> — если загрузка не удалась.</p>

<pre><code>var font = new FontFaceObserver('Output Sans');
var html = document.documentElement;

html.classList.add('fonts-loading');

font.load().then(function () {
html.classList.remove('fonts-loading');
html.classList.add('fonts-loaded');
}).catch(function () {
html.classList.remove('fonts-loading');
html.classList.add('fonts-failed');
});
</code></pre>

<p>При помощи этих классов и простого CSS вы можете кроссбраузерно использовать FOUT. Начнём с объявления запасных шрифтов для всех элементов, которым понадобятся веб-шрифты. Когда в <code>&lt;html&gt;</code> появляется класс <code>fonts-loaded</code>, мы применяем веб-шрифт, изменяя цепочку шрифтов для всех соответствующих элементов. Изменение правила в CSS заставит браузер загрузить веб-шрифт, однако, поскольку к этому моменту он уже будет загружен, перерисовка начнется практически мгновенно.</p>

<pre><code>body {
font-family: Verdana, sans-serif;
}

.fonts-loaded body {
font-family: Output Sans, Verdana, sans-serif;
}
</code></pre>

<p>Такой способ загрузки шрифтов может показаться вам похожим на технику прогрессивного улучшения. Так оно и есть: <em>мелькание текста без стилей</em> (FOUT) соответствует прогрессивному улучшению. Базовый вид в первую очередь отрисовывается запасными шрифтами, а затем улучшается веб-шрифтами.</p>

<p>Реализация FOIT такая же простая. Когда веб-шрифты начинают загрузку, вы скрываете контент, использующий шрифты, а когда они загружены, вы показываете его снова. Не забывайте и об ошибке загрузки — контент должен быть доступен, даже если шрифты не смогли загрузиться.</p>

<pre><code>.fonts-loading body {
visibility: hidden;
}

.fonts-loaded body,
.fonts-failed body {
visibility: visible;
}
</code></pre>

<p>Такой способ сокрытия контента кажется вам странным? Хорошо, если так. Этот паттерн следует применять только в очень специфичных случаях. Например, если у вас нет подходящего запасного шрифта, или вы точно знаете, что шрифт был закэширован ранее.</p>

<h2><a id="ch6"></a>Оптимизация для кэширования</h2>

<p>Все предыдущие паттерны позволяли вам регулировать когда и как загружаются шрифты. Однако, часто мы хотим, чтобы в зависимости от наличия или отсутствия шрифта в кэше сайт вёл себя по-разному. Например, если шрифт закэширован, нет необходимости отрисовывать текст сначала запасным шрифтом. Такого эффекта можно добиться сохранением в Ses­sion Stor­age статуса о том, был ли шрифт закэширован или нет.</p>

<p>Когда шрифт загружен, мы устанавливаем флаг в Ses­sion Stor­age. Флаг сохраняется на протяжении всей сессии, и с его помощью мы можем определить, находится файл в браузерном кэше или нет.</p>

<pre><code>var font = new FontFaceObserver('Output Sans');

font.load().then(function () {
sessionStorage.fontsLoaded = true;
}).catch(function () {
sessionStorage.fontsLoaded = false;
});
</code></pre>

<p>Теперь вы можете использовать эту информацию, чтобы изменить стратегию загрузки закэшированных шрифтов. Например, можно включить такой фрагмент JavaScript в элемент <code>&lt;head&gt;</code> вашей страницы, чтобы сразу же отрисовывать веб-шрифты.</p>

<pre><code>if (sessionStorage.fontsLoaded) {
var html = document.documentElement;

html.classList.add('fonts-loaded');
}
</code></pre>

<p>Если вы будете загружать шрифты этим способом, ваши посетители увидят FOUT только при первом посещении сайта, а при всех дальнейших переходах шрифт будет отрисовываться мгновенно. А значит, с одной стороны, вы сохраните выгоды, которые даёт прогрессивное улучшение, а с другой — сделаете сайт удобным, поскольку загрузка страниц будет меньше раздражать при повторных посещениях.</p>


# 4 вида утечек памяти в JavaScript и как с ними бороться

В этой статье мы рассмотрим распространённые виды утечек памяти в клиентском JavaScript. Также мы узнаем, как их обнаружить с помощью Chrome Development Tools.

---

_Примечание переводчика:_ первая часть статьи насыщена примечаниями переводчика. В ходе анализа материала стало понятно, что некоторые моменты стоит отдельно пояснить.

## Вступление

Утечки памяти принадлежат к тому роду задач, с которыми рано или поздно сталкивается каждый разработчик. Языки с автоматическим управлением памятью не решают все проблемы разом — всё равно существуют ситуации, когда память утекает. Утечки порождают целый класс различных проблем: задержки в работе пользовательского интерфейса, зависания и даже проблемы работы с другими приложениями.

### Что такое утечка памяти?

Утечка памяти — память, которая больше не требуется приложению, но по какой-то причине не возвращается операционной системе или [пулу доступной памяти](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8) (_примечание переводчика:_ [в кучу](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C))). Языки программирования используют разные подходы, снижающие риск возникновения утечек памяти, однако сама задача о том, понадобится ли ещё определенный фрагмент памяти или нет, [алгоритмически неразрешима](https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management#%D0%9E%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0_%D0%BE%D0%BD%D0%B0_%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5_%D0%BD%D0%B5_%D0%BD%D1%83%D0%B6%D0%BD%D0%B0) (_примечание переводчика:_ она сводится к [проблеме остановки](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8)). Иными словами, только разработчик может определить, возможно ли вернуть определенный фрагмент памяти операционной системе. Управление памятью в языках программирования делится на ручное и автоматическое. Первый тип предоставляет разработчику набор инструментов, помогающих напрямую взаимодействовать с памятью. Во втором существует специальный процесс, называемый «сборщиком мусора» (_англ._ garbage collector), вызываемый автоматически и удаляющий память. 

_Примечание переводчика:_ более подробно это описано в Википедии: [сборка мусора](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0), [manual memory management](https://en.wikipedia.org/wiki/Manual_memory_management), [garbage collection](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)).

### Управление памятью в JavaScript

JavaScript — язык программирования со встроенным сборщиком мусора. Сборщик периодически проверяет, какие из выделенных приложению фрагментов памяти остаются «достижимы» из различных частей этого приложения. Иными словами, сборщик мусора переводит вопрос «какая память до сих пор нужна?» в вопрос «к какой памяти можно обратиться?». Разница кажется незначительной, однако это не так: хотя лишь разработчик знает, потребуется ли фрагмент выделенной памяти в будущем или нет, недостижимую память можно вычислить алгоритмически и пометить к возвращению в ОС.

Языки, не имеющие сборщиков мусора, работают по другим принципам. Например, существует явное управление памятью: разработчик напрямую говорит компилятору, когда данный фрагмент памяти можно удалить. Также существует алгоритм подсчёта ссылок, при котором с каждым блоком памяти ассоциируется количество его использований (и когда оно обнулится, блок возвращается в ОС). Эти техники имеют свои плюсы и минусы, и могут привести к утечкам памяти.

_Примечание переводчика:_ алгоритм подсчёта ссылок используется и в сборщиках мусора. Кроме того, стоит заметить, что работа этого алгоритма в базовом виде может привести к возникновению циклических ссылок, при котором неиспользуемые объекты ссылаются друг на друга, взаимно блокируя удаление. Подробнее — [в Википедии](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA).


## Утечки памяти в JavaScript

Главной причиной утечек памяти в языках со сборщиками мусора являются _нежелательные ссылки_. Чтобы понять, что это такое, давайте сначала рассмотрим, как именно сборщик мусора проверяет достижимость объектов.

### Алгоритм пометок (Mark-and-sweep)

Большинство сборщиков мусора используют алгоритм пометок (_mark-and-sweep_):

1. Сборщик мусора строит список «корневых объектов», или «корней». Как правило ими становятся объявленные в коде глобальные переменные. В JavaScript типичный корень — объект `window`. Так как `window` существует на протяжении всей работы страницы, сборщик мусора поймёт, что этот объект и его потомки всегда будут присутствовать в среде исполнения программы (т.е. не станут мусором).

2. Сборщик рекурсивно обходит корни и их потомков, помечая их как активные (т.е. не мусор). Всё, до чего можно добраться из корня, не рассматривается в качестве мусора.

3. После второго шага фрагменты памяти, не помеченные как активные, могут считаться мусором. Теперь сборщик может освободить эту память и вернуть в ОС.

Современные сборщики мусора улучшают этот алгоритм, но его суть остаётся прежней: пометить достижимые фрагменты памяти, а остальное объявить мусором. Теперь можно дать определение _нежелательным ссылкам_ — это ссылки, достижимые из корня, но ссылающиеся на фрагменты памяти, которые точно никогда больше не понадобятся. В JavaScript _нежелательными ссылками_ станут потерявшие актуальность переменные, забытые в коде, удерживающие в памяти ненужные более объекты. Кстати, некоторые считают, что это ошибки разработчиков, а не языка.

Итак, чтобы выяснить, из-за чего обычно возникают утечки памяти в JavaScript, мы должны понять, какие ситуации приводят к возникновению _нежелательных ссылок_.

_Примечание переводчика:_ перед тем, как читать дальше, рекомендую посмотреть статью MDN об [управлении памятью](https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management), более подробно раскрывающую тему.

## Четыре самых распространённых вида утечек памяти в JavaScript

_Примечание переводчика:_ здесь и далее в примерах мы будем рассматривать клиентский JavaScript. Будет считать без излишних уточнений и оговорок, что у нас есть глобальный объект `window`. В иной среде исполнения JavaScript `window` может не быть, однако обсуждаемые в статье причины утечек будут актуальны.

### 1: Случайные глобальные переменные

Одной из целей, стоявших при разработке JavaScript, было создать похожий на Java язык, но настолько нестрогий, чтобы с ним могли работать даже новички. Одним из послаблений языка стала обработка необъявленных переменных: обращение к такой переменной создаст новую переменную в _глобальном_ объекте. Таким образом, если рассмотреть код:

```js
function foo(arg) {
    bar = "скрытая глобальная переменная";
}
```

На самом деле он означает:

```js
function foo(arg) {
    window.bar = "явно объявленная глобальная переменная";
}
```

Если вы хотите, чтобы `bar` содержала ссылку на переменную лишь внутри области видимости функции `foo`, но забыли указать в объявлении `var`, то будет создана глобальная переменная. В данном случае утечку памяти создаст простая строка. Много вреда это не причинит, но, конечно, ситуация могла бы быть намного хуже. 

Ещё один способ создать случайную глобальную переменную — использовать `this`:

```js
function foo() {
    this.variable = "potential accidental global";
}

// Если foo вызвать саму по себе, this будет указывать на глобальный объект (window), 
// вместо того, чтобы быть undefined.
foo();
```

Чтобы избежать подобных ошибок, добавляйте `'use strict'`; в начало JavaScript-файлов. Это директива, включающая строгий режим парсинга JavaScript, препятствующий возникновению случайных глобальных переменных.


```js
```

---

_Оригинал: [4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them](http://google.com/), автор: [Sebastián Peyrott](https://twitter.com/speyrott)._

_Перевод: [Андрей Алексеев](https://github.com/aalexeev239/), редактура: [Замечательный человек](http://google.com/) и [Гениальный критик](http://google.com/)._
